#!/bin/bash
# shellcheck disable=SC2154,SC1091
#
# Copyright:: Copyright 2017 Chef Software, Inc.
# License:: Apache License, Version 2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

document "setup_go_workspace" <<DOC
  Setup the Go Workspace. (requires \$pkg_scaffolding to be set)

  This function will leverage the scaffolding-go configured at \$pkg_scaffolding.
  It will install it and use the go_before callback to setup the Go Workspace.
  If there are no libraries/callbacks, it will still configure it by linking the /src
  directory into the Go Workspace.
DOC
function setup_go_workspace() {
  # Verify that we are using the Go Scaffolding
  if [[ ! "$pkg_scaffolding" =~ "scaffolding-go" ]]; then
    echo "ERROR: Unable to setup Go Workspace."
    echo "${FUNCNAME[0]}: requires the 'pkg_scaffolding' variable to exist in your plan.sh"
    return 2;
  fi;

  # Verify if the Go Workspace has been already configured
  [[ $scaffolding_go_workspace_src  ]] && return 0;

  # Currently the scaffolding-go has all the logic to setup the
  # Go Workspace, lets leverage all its functionality
  echo "=> Configuring Go Workspace. [please wait]"
  export scaffolding_go_gopath=${scaffolding_go_gopath:-/hab/cache/src/go};
  install $pkg_scaffolding >/dev/null;
  source "$(hab pkg path $pkg_scaffolding)/lib/"*
  export PATH="$PATH:${scaffolding_go_gopath}/bin"

  # Verify if we have the go_before callback
  # If not lets setup the workspace ourself
  go_before_callback=scaffolding_go_before
  if [ -n "$(type -t $go_before_callback)" ] && [ "$(type -t $go_before_callback)" = function ]
  then
    eval "$go_before_callback";
  else
    mkdir -p "${scaffolding_go_workspace_src}/${scaffolding_go_base_path}";
    if [[ ! -e "$scaffolding_go_pkg_path" ]]; then
      ln -s /src "$scaffolding_go_pkg_path";
    fi;
  fi;

  # Install go & git
  install_if_missing core/go go;
  install_if_missing core/git git;

  echo "=> Available scaffolding variables:";
  echo "\$scaffolding_go_gopath        - $scaffolding_go_gopath";
  echo "\$scaffolding_go_workspace_src - $scaffolding_go_workspace_src";
  echo "\$scaffolding_go_pkg_path      - $scaffolding_go_pkg_path";
  return 0;
}

document "enter_go_workspace" <<DOC
  Change dir to the $pkg_name Go Workspace.

  It will automatically setup the Go Workspace if missing
DOC
function enter_go_workspace() {
  setup_go_workspace
  cd $scaffolding_go_pkg_path
}
add_alias "enter_go_workspace" "egw"

document "install_go_tool" <<DOC
  Install the specified go tool(s).

  @(arg:*) The array of packages you wish to install.

  The default behavior is to install go tools with 'go get -u' but you can override
  this by specifying the \$GO_TOOL_METHOD="install" so that it uses 'go install -v'
  instead, be aware that you have to have a vendor/ directory with the tools.

  Example 1 :: Install the listed go tool generating a static linked binary
  ---------------------------------------------------------------------------------
  GO_STATIC_BIN=true install_go_tool github.com/golang/dep/cmd/dep

  Example 2 :: Install a go tool that you in your local vendor/ directory
  --------------------------------------------------------------------------
  local proto_go_tools=(
    github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway
    github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger
    github.com/golang/protobuf/protoc-gen-go
  )
  GO_TOOL_METHOD="install" install_go_tool \${proto_go_tools[@]}
DOC
function install_go_tool() {
  setup_go_workspace
  local go_cmd="go get -u";
  [[ "$GO_TOOL_METHOD" == "install" ]] && go_cmd="go install -v";

  # Add static linked flags if needed
  go_cmd="$go_cmd $(go_static_linked_flags)";

  pushd $GOPATH >/dev/null;
  for i in "$@"; do
    go_tool=$(basename $i);
    if [[ ! -f "${GOPATH}/bin/${go_tool}" ]]; then
      echo "=> Installing Go Tool '${go_tool}'";
      if [[ "$GO_TOOL_METHOD" == "install" ]]; then
        eval "$go_cmd $scaffolding_go_base_path/$pkg_name/vendor/$i";
      else
        eval "$go_cmd $i";
      fi;
    fi;
  done;
  popd >/dev/null;
}

document "go_build" <<DOC
  Builds the $pkg_name binary. (a.k.a. go build)

  @(arg:1) The path to the go main package (default: cmd/${pkg_name}/${pkg_name}.go)

  This helper will enfore the Go Workspace configureation.

  Example 1 :: Build a static linked binary.
  ------------------------------------------
  GO_STATIC_BIN=true go_build main.go

  Available extra steps before building the binary:

  1) To run 'go generate' set:
  => export RUN_GO_GENERATE=true

  2) To run 'dep ensure' set:
  => export RUN_GO_DEP=true

  Example 2 :: Build the default binary without deps and/or 'go generate'.
  ------------------------------------------------------------------------
  GO_FAST=true go_build
DOC
function go_build() {
  [[ "$1" == "" ]] && go_main="cmd/${pkg_name}/${pkg_name}.go" || go_main=$1

  # Setup the go workspace
  setup_go_workspace

  local go_cmd="go build"

  # Add static linked flags if needed
  go_cmd="$go_cmd $(go_static_linked_flags)";

  if [[ $GO_STATIC_BIN == true ]]; then
    install_if_missing core/musl musl-gcc;
    export CC=$(hab pkg path core/musl)/bin/musl-gcc;
  fi

  pushd $scaffolding_go_pkg_path >/dev/null
    if [[ $GO_FAST != true ]]; then
      [[ $RUN_GO_GENERATE == true ]] && echo "=> Executing Go generate" && go generate
      [[ $RUN_GO_DEP == true ]] && dep_ensure
    fi;
    echo "=> Executing Go build"
    eval "$go_cmd $go_main"
    # Save the exit code to return it latter
    # this will make the function to exit with
    # a non-zero code and don't procees from there
    EXIT_CODE=$?
  popd >/dev/null
  return $EXIT_CODE
}
add_alias "go_build" "gb"

document "dep_ensure" <<DOC
  Runs the go dependency solver. (a.k.a. dep ensure)

  This helper will ensure your Go workspace is configured and that
  you have the dep tool installed.

  Set 'GO_FAST=true' env variable to skip this task only for faster
  development cycles.
DOC
function dep_ensure() {
  local go_cmd="dep ensure";
  if [[ $GO_FAST != true ]]; then
    echo "(help) You can always set 'GO_FAST=true' to go faster!";
    install_go_tool github.com/golang/dep/cmd/dep;
    echo "=> Executing Go dependency solver ($go_cmd)";
    pushd $scaffolding_go_pkg_path >/dev/null;
      eval $go_cmd;
      local EXIT_CODE=$?;
    popd >/dev/null;
  fi;
  return $EXIT_CODE;
}
add_alias "dep_ensure" "de"

# This function will be your first place for debugging your Go service,
# once you are inside the debug console you can set breakpoints and more.
#
#   Docs => https://github.com/derekparker/delve/tree/master/Documentation/cli
#
# The helper expects you to implement two methods:
# => start_dependencies - That will start the service dependencies
# => service_parameters - That should provide the service parameters to start the service with
document "go_debug_mode" <<DOC
  Runs the $pkg_name in debug mode inside the studio.

  @(arg:1) The path to the go main package (default: cmd/${pkg_name}/${pkg_name}.go)

  Example 1 :: Passing a custom go main package
  ---------------------------------------------------------
  go_debug_mode app/main.go

  Example 2 :: Add extra options to the 'dlv debug' command
  ---------------------------------------------------------
  GO_DEBUG_OPTS="--init string" go_debug_mode

  This helper expects you to implement two methods:
    => start_dependencies - That will start the service dependencies
    => service_parameters - That should provide the service parameters to start the service with

  Example of the 'service_parameters' function to define
  ---------------------------------------------------------
  function service_parameters() {
    echo "start --host \$HOST --port \$PORT --elasticsearch-url \$ELASTICSEARCH_URL"
  }
DOC
function go_debug_mode() {
  [[ "$1" == "" ]] && go_main="cmd/${pkg_name}/${pkg_name}.go" || go_main=$1

  local go_cmd="dlv debug"
  local pid=$(grep_service_pid)
  if [[ ! -z ${pid} ]]; then
    echo "There is a $pkg_name running. (${pid})"
    echo "Stop the service with 'stop_service' then re-run '${FUNCNAME[0]}'"
    return 1
  fi

  # Install the debugging tooli
  install_go_tool github.com/derekparker/delve/cmd/dlv;

  # Start the service dependencies if defined
  if [[ "$(type -t start_dependencies)" == "function" ]]; then
    start_dependencies
  fi;

  # Add the main go package to debug
  go_cmd="$go_cmd $go_main";

  # Add static linked flags if needed
  local flags=$(go_static_linked_flags)
  [ "x${flags}" != "x" ] && go_cmd="$go_cmd --build-flags \"$flags\"";

  # Add extra debug options, helpful to stand up a Delve Server
  [ "x${GO_DEBUG_OPTS}" != "x" ] && go_cmd="$go_cmd $GO_DEBUG_OPTS";

  # If 'service_parameters' function exists, pass it to the debugger
  if [[ "$(type -t service_parameters)" == "function" ]]; then
    go_cmd="$go_cmd -- $(service_parameters)"
  fi;

  pushd $scaffolding_go_pkg_path >/dev/null;
    [[ $go_cmd != *"headless"* ]] && echo "=> Starting debug console:"
    eval $go_cmd
  popd >/dev/null
}
add_alias "go_debug_mode" "gdm"

# Starts a headless Delve Server so that engineers that use IDE's like VS Code
# can connect to the remote service running in our habitat studio
#
# Default headless Delve Server port ':2345'
document "go_debug_server" <<DOC
  Starts a headless Delve Server to remotely debug the $pkg_name

  @(arg:1) The port to start the Delve Server (default: 2345)"

  NOTE: You have to set the 'HAB_DOCKER_OPTS' environment variable before entering
  the Studio so that Docker exposes the provided port. Ex. 'HAB_DOCKER_OPTS="-p 2345:2345"'
DOC
function go_debug_server() {
  local port=2345
  [[ "x$1" != "x" ]] && port=$1;
  echo "=> Starting headless Delve Server in port '*:$port'"
  GO_DEBUG_OPTS="--headless --listen=:$port --log" go_debug_mode
}
add_alias "go_debug_server" "gds"

# You wanna debug your running process? Well use this function to do so.
document "go_debug_attach_running_service" <<DOC
  Attach to a running $pkg_name and begin debugging inside the studio.
DOC
function go_debug_attach_running_service() {
  local pid=$(grep_service_pid)
  if [[ -z ${pid} ]]; then
    echo "There is no $pkg_name running."
    return 1
  fi
  go_debug_attach_to_pid $pid
}
add_alias "go_debug_attach_running_service " "gdas"


# Connect to the provided PID process (Must be a Go Applicaiton)
document "go_debug_attach_to_pid" <<DOC
  Attach to the provided PID and begin debugging inside the studio.

  @(arg:1) The PID to attach to (must be a Go application)
DOC
function go_debug_attach_to_pid() {
  if [[ -z $1 ]]; then
    echo "You have to provide a PID to attach to"
    echo "Run 'describe ${FUNCNAME[0]}' for more information"
    return 1
  fi

  local go_cmd="dlv attach $1 $pkg_name"
  # Add static linked flags if needed
  local flags=$(go_static_linked_flags)
  [ "x${flags}" != "x" ] && go_cmd="$go_cmd --build-flags \"$flags\"";

  install_go_tool github.com/derekparker/delve/cmd/dlv;
  pushd $scaffolding_go_pkg_path >/dev/null;
    echo "=> Connection to PID '${1}':"
    eval $go_cmd
  popd >/dev/null
}
add_alias "go_debug_attach_to_pid " "gdatt"

# Helper function to search for the PID of the service
function grep_service_pid() {
  install_if_missing core/busybox-static pgrep;
  pgrep $pkg_name
}

# Helper function that you can call to detect if the user builds statically linked Go binaries
function go_static_linked_flags() {
  if [[ $GO_STATIC_BIN == true ]]; then
    install_if_missing core/musl musl-gcc;
    install_if_missing core/gcc gcc;
    export CC=$(hab pkg path core/musl)/bin/musl-gcc;
    export GO_LDFLAGS="-linkmode external -extldflags '-static'";
    echo "--ldflags '$GO_LDFLAGS'";
  fi;
}
